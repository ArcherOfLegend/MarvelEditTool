use std::collections::{HashMap, HashSet};
use std::fs;
use std::path::PathBuf;

use anyhow::{Context, Result, bail};
use clap::{Parser, Subcommand};
use marveledata::types::first::Model;
use marveledata::{load_first, save_first};
use tempfile::NamedTempFile;

#[derive(Debug, Parser)]
#[command(author, version, about = "Marvel vs. Capcom 3 ANMCHR inspector", long_about = None)]
#[command(arg_required_else_help = true, subcommand_required = true)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Debug, Subcommand)]
enum Commands {
    /// Convert a binary ANMCHR pointer table into JSON.
    Dump {
        /// Path to the ANMCHR binary file.
        input: PathBuf,
        /// Optional output file for the generated JSON. Writes to stdout when omitted.
        #[arg(short, long)]
        out: Option<PathBuf>,
    },
    /// Apply JSON edits back onto a template ANMCHR file.
    Write {
        /// Path to the JSON edits.
        json: PathBuf,
        /// Path to the original ANMCHR binary used as a layout template.
        #[arg(short, long)]
        template: PathBuf,
        /// Destination path for the regenerated binary.
        #[arg(short, long)]
        out: PathBuf,
    },
    /// Validate that an ANMCHR file can be parsed and regenerated without loss.
    Validate {
        /// Path to the ANMCHR binary file.
        input: PathBuf,
    },
}

fn main() {
    let cli = Cli::parse();

    if let Err(err) = run(cli) {
        eprintln!("error: {:#}", err);
        std::process::exit(1);
    }
}

fn run(cli: Cli) -> Result<()> {
    match cli.command {
        Commands::Dump { input, out } => dump(input, out),
        Commands::Write {
            json,
            template,
            out,
        } => write(json, template, out),
        Commands::Validate { input } => validate(input),
    }
}

fn dump(input: PathBuf, out: Option<PathBuf>) -> Result<()> {
    let model = load_first(&input).with_context(|| {
        format!(
            "failed to load FIRST pointer table from {}",
            input.display()
        )
    })?;
    let json = serde_json::to_string_pretty(&model)
        .context("failed to serialize pointer table to JSON")?;

    if let Some(path) = out {
        fs::write(&path, json)
            .with_context(|| format!("failed to write JSON to {}", path.display()))?;
    } else {
        println!("{}", json);
    }

    Ok(())
}

fn write(json: PathBuf, template: PathBuf, out: PathBuf) -> Result<()> {
    let template_model = load_first(&template)
        .with_context(|| format!("failed to load template file from {}", template.display()))?;

    let reader = fs::File::open(&json)
        .with_context(|| format!("failed to open JSON edits at {}", json.display()))?;
    let edits: Model = serde_json::from_reader(reader)
        .with_context(|| format!("failed to parse JSON edits from {}", json.display()))?;

    let merged = merge_models(template_model, edits)?;

    save_first(&out, &merged)
        .with_context(|| format!("failed to write regenerated table to {}", out.display()))?;

    Ok(())
}

fn validate(input: PathBuf) -> Result<()> {
    let original = fs::read(&input)
        .with_context(|| format!("failed to read ANMCHR bytes from {}", input.display()))?;
    let model = load_first(&input)
        .with_context(|| format!("failed to load pointer table from {}", input.display()))?;

    let scratch = NamedTempFile::new().context("failed to create scratch file for validation")?;
    save_first(scratch.path(), &model)
        .context("failed to regenerate pointer table during validation")?;
    let regenerated =
        fs::read(scratch.path()).context("failed to read regenerated pointer table")?;

    if original != regenerated {
        bail!("validation failed: regenerated bytes differ from input");
    }

    println!("{}: OK", input.display());
    Ok(())
}

fn merge_models(mut template: Model, edits: Model) -> Result<Model> {
    if template.header != edits.header {
        bail!(
            "JSON header does not match template header; rerun dump on the template to refresh the edits"
        );
    }

    if template.entries.len() != edits.entries.len() {
        bail!(
            "JSON edits contain {} entries, but template requires {} entries",
            edits.entries.len(),
            template.entries.len()
        );
    }

    let mut index_to_position: HashMap<u32, usize> = HashMap::new();
    for (position, entry) in template.entries.iter().enumerate() {
        if index_to_position.insert(entry.index, position).is_some() {
            bail!("template contains duplicate entry index {:#x}", entry.index);
        }
    }

    let mut seen = HashSet::new();
    for entry in edits.entries {
        if !seen.insert(entry.index) {
            bail!(
                "JSON edits contain duplicate entry index {:#x}",
                entry.index
            );
        }
        let &position = index_to_position.get(&entry.index).ok_or_else(|| {
            anyhow::anyhow!(
                "JSON entry index {:#x} is missing from the template",
                entry.index
            )
        })?;
        let template_entry = &mut template.entries[position];
        if entry.offset != template_entry.offset {
            bail!(
                "JSON entry {:#x} offset {:#x} does not match template offset {:#x}",
                entry.index,
                entry.offset,
                template_entry.offset
            );
        }
        template_entry.data = entry.data;
    }

    Ok(template)
}
