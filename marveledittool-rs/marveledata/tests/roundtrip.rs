use std::fs;
use std::io::Write;

use marveledata::{load_first, save_first};
use tempfile::NamedTempFile;

fn first_sample_bytes() -> Vec<u8> {
    include_str!("data/first/pointer_table.hex")
        .split_whitespace()
        .map(|byte| u8::from_str_radix(byte, 16).expect("valid hex byte"))
        .collect()
}

fn mask_first(bytes: &mut [u8]) {
    // The legacy C# implementation does not patch any checksums or timestamps while
    // round-tripping `TableFile` pointer tables, so there are no volatile regions to mask.
    // Keep the helper around so that future FIRST fixtures with dynamic bytes can
    // document explicit offsets here.
    let _ = bytes;
}

#[test]
fn sample_file_is_non_empty() {
    let bytes = first_sample_bytes();

    assert!(!bytes.is_empty(), "sample fixture must not be empty");
}

#[test]
fn table_round_trip_preserves_bytes() {
    let bytes = first_sample_bytes();
    let mut input = NamedTempFile::new().expect("create temp input file");
    input
        .write_all(&bytes)
        .expect("write fixture bytes to temp file");
    input.flush().expect("flush temp input file");

    let model = load_first(input.path()).expect("parser should succeed");

    let output = NamedTempFile::new().expect("create temp output file");
    save_first(output.path(), &model).expect("writer should succeed");

    let regenerated = fs::read(output.path()).expect("read regenerated bytes");
    assert_eq!(bytes, regenerated, "round trip must match byte-for-byte");
}

#[test]
fn golden_first_round_trip_via_json() {
    let bytes = first_sample_bytes();

    let mut input = NamedTempFile::new().expect("create temp input file");
    input
        .write_all(&bytes)
        .expect("write fixture bytes to temp file");
    input.flush().expect("flush temp input file");

    let model = load_first(input.path()).expect("parser should succeed");

    let json = serde_json::to_string_pretty(&model).expect("serialize model to json");
    let parsed = serde_json::from_str(&json).expect("deserialize model from json");

    let output = NamedTempFile::new().expect("create temp output file");
    save_first(output.path(), &parsed).expect("writer should succeed");

    let mut expected = bytes;
    let mut actual = fs::read(output.path()).expect("read regenerated bytes");

    mask_first(&mut expected);
    mask_first(&mut actual);

    assert_eq!(
        expected, actual,
        "masked round-trip must match byte-for-byte"
    );
}
